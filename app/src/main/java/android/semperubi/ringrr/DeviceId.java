package android.semperubi.ringrr;

import android.content.Context;
import android.content.SharedPreferences;
import android.provider.Settings;
import android.telephony.TelephonyManager;

import java.io.FileInputStream;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.UUID;


/**
 * A collection of methods for extracting stable device identifiers.
 *
 * @author Philip DeCamp
 */
public class DeviceId {

    public enum Type {
        ANDROID_ID      ("ai"),
        SELF_GENERATED  ("sg"),
        SERIAL_NUMBER   ("sn"),
        TELEPHONE_ID    ("ti"),
        WIFI_MAC        ("wm" ),

        OTHER           ("xx");

        final String mPrefix;

        Type( String prefix ) {
            mPrefix = prefix;
        }
    }

    /**
     * Attempts to find most reliable DeviceID possible for given device.
     */
    public static DeviceId findBest( Context context ) {
        DeviceId ret;

        ret = fromWifiMac();
        if( ret != null ) {
            return ret;
        }

        ret = fromTelephoneId( context );
        if( ret != null ) {
            return ret;
        }

        ret = fromAndroidId( context );
        if( ret != null ) {
            return ret;
        }

        ret =  fromSerialNumber();
        if( ret != null ) {
            return ret;
        }

        return fromSelfGenerated( context );
    }

    /**
     * Reads the Android-provided ID string. This value is generated by the
     * operating system and may be wiped. This value is not guaranteed to be
     * unique and some devices may not have an ID at all due to bugs in Android,
     * particularly V2.2.
     */
    public static DeviceId fromAndroidId( Context context ) {
        return hash( Type.ANDROID_ID, readAndroidId( context ) );
    }


    public static String readAndroidId( Context context ) {
        try {
            String str = Settings.Secure.getString( context.getContentResolver(), Settings.Secure.ANDROID_ID );
            return contains( BAD_ANDROID_IDS, str ) ? null : str;
        } catch( Exception ignore ) {
            return null;
        }
    }

    /**
     * Tries to read a number from a set position in device storage.
     * If this number is not present, attempts to create it, randomly.
     * This number can easily be removed by user or system and should
     * be used as last resort.
     */
    public static DeviceId fromSelfGenerated( Context context ) {
        SharedPreferences prefs = null;

        try {
            prefs = context.getSharedPreferences( ".device_id.xml", Context.MODE_MULTI_PROCESS );
            String str = prefs.getString( "device_id", null );
            if( str != null ) {
                return new DeviceId( Type.SELF_GENERATED, Uuids.fromHex( str ) );
            }
        } catch( Exception ignored ) {}

        DeviceId id = new DeviceId( Type.SELF_GENERATED, Uuids.createRandom() );

        if( prefs != null ) {
            try {
                prefs.edit().putString( "device_id", Uuids.toHex( id.mId ) ).apply();
            } catch( Exception ignore ) {}
        }

        return id;
    }

    /**
     * Attempts to retrieve the serial number of the device. This is the most permanent form
     * of DeviceId, but access to serial number is not normally public and this
     * method may not work in future versions. Further, many devices do not report unique serial numbers.
     */
    public static DeviceId fromSerialNumber() {
        return hash( Type.SERIAL_NUMBER, readSerialNumber() );
    }


    public static String readSerialNumber() {
        try {
            Class<?> c = Class.forName( "android.os.SystemProperties" );
            Method get = c.getMethod( "get", String.class );
            String str = (String)get.invoke( c, "ro.serialno" );
            return contains( BAD_SERIAL_NOS, str ) ? null : str;
        } catch( Exception ignored ) {}

        return null;
    }

    /**
     * Attepmts to read ID of device telephone. Supposed to be
     * quite robust, but many devices do not seem to provide
     * one.
     */
    public static DeviceId fromTelephoneId( Context context ) {
        return hash( Type.TELEPHONE_ID, readTelephoneId( context ) );
    }


    public static String readTelephoneId( Context context ) {
        try {
            return ((TelephonyManager)context.getSystemService( Context.TELEPHONY_SERVICE )).getDeviceId();
        } catch( Exception ex ) {
            return null;
        }
    }

    /**
     * Attempts to retrieve the MAC address of the Wifi Adapter and convert that
     * to a DeviceId. MAC addresses can be changed, but seldom are.
     */
    public static DeviceId fromWifiMac() {
        return hash( Type.WIFI_MAC, readWifiMac() );
    }


    public static String readWifiMac() {
        try {
            FileInputStream in = new FileInputStream( "/sys/class/net/wlan0/address" ) ;
            byte[] buf = new byte[17];
            int off = 0;
            while( off < buf.length ) {
                int n = in.read( buf, off, buf.length - off );
                if( n <= 0 ) {
                    break;
                }
                off += n;
            }

            return new String( buf, StandardCharsets.UTF_8 );
        } catch( Exception ignore ) {}

        return null;
    }

    /**
     * Parses a DeviceId that has been converted to String with {@link #toString}.
     */
    public static DeviceId fromString( String str ) {
        if( str.length() != 22 + PREFIX_LEN ) {
            return null;
        }

        final UUID id;

        try {
            id = Uuids.fromUrl( str.substring( PREFIX_LEN ) );
        } catch( IllegalArgumentException ex ) {
            return null;
        }

        final String prefix = str.substring( 0, PREFIX_LEN ).intern();
        for( Type t: Type.values() ) {
            if( prefix == t.mPrefix ) {
                return new DeviceId( t, id );
            }
        }

        return null;
    }



    public final Type mType;
    public final UUID mId;


    public DeviceId( Type type, UUID id ) {
        mType = type;
        mId = id;
    }



    public int hashCode() {
        return mId.hashCode();
    }


    public boolean equals( Object obj ) {
        if( !( obj instanceof DeviceId ) ) {
            return false;
        }

        DeviceId d = (DeviceId)obj;
        return mId.equals( d.mId ) &&
               mType == d.mType;
    }


    public String toString() {
        return mType.mPrefix + Uuids.toUrl( mId );
    }



    private static final int PREFIX_LEN = 2;

    // There was a bug in Android 2.2 with AndroidID that caused all devices to have the ID 9774d56d682e549c
    private static final String[] BAD_ANDROID_IDS = { "9774d56d682e549c" };

    // Many low-end devices have Serial No "0123456789ABCDEF".
    private static final String[] BAD_SERIAL_NOS  = { "0123456789abcdef", "0000000000000000" };


    private static boolean contains( String[] arr, String v ) {
        if( v == null ) {
            return false;
        }
        for( String a: arr ) {
            if( a.equalsIgnoreCase( v ) ) {
                return true;
            }
        }
        return false;
    }


    private static DeviceId hash( Type type, String str ) {
        return str == null ? null : new DeviceId( type, Uuids.fromName( null, str ) );
    }

}
